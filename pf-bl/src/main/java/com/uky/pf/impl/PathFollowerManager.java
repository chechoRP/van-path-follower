//  (c) Copyright 2013 Hewlett-Packard Development Company, L.P.
//  Autogenerated
package com.uky.pf.impl;

import java.util.UUID;

import static com.hp.util.StringUtils.isEmpty;
import static com.hp.of.lib.instr.ActionFactory.createAction;
import static com.hp.of.lib.match.MatchFactory.createMatch;
import static com.hp.of.lib.match.FieldFactory.createBasicField;
import static com.hp.of.ctl.prio.FlowClass.ActionClass.*;

import com.uky.pf.model.PathFollower;
import com.uky.pf.api.PathFollowerService;

import com.hp.api.NotFoundException;
import com.hp.of.ctl.ControllerService;
import com.hp.of.ctl.ErrorEvent;
import com.hp.of.ctl.FlowClassRegistrator;
import com.hp.of.ctl.pkt.MessageContext;
import com.hp.of.ctl.pkt.PacketListenerRole;
import com.hp.of.ctl.pkt.SequencedPacketListener;
import com.hp.of.ctl.prio.FlowClass;
import com.hp.of.lib.OpenflowException;
import com.hp.of.lib.ProtocolVersion;
import com.hp.of.lib.dt.BufferId;
import com.hp.of.lib.dt.DataPathId;
import com.hp.of.lib.dt.DataPathInfo;
import com.hp.of.lib.dt.TableId;
import com.hp.of.lib.instr.ActOutput;
import com.hp.of.lib.instr.Action;
import com.hp.of.lib.instr.ActionType;
import static com.hp.of.lib.match.OxmBasicFieldType.*;
import com.hp.of.lib.match.Match;
import com.hp.of.lib.match.MatchField;
import com.hp.of.lib.match.MutableMatch;
import com.hp.of.lib.match.OxmBasicFieldType;
import com.hp.of.lib.msg.FlowModCommand;
import com.hp.of.lib.msg.MessageFactory;
import com.hp.of.lib.msg.MessageType;
import com.hp.of.lib.msg.OfmFlowMod;
import com.hp.of.lib.msg.OfmMutableFlowMod;
import com.hp.of.lib.msg.Port;
import com.hp.util.ip.EthernetType;
import com.hp.util.pkt.ProtocolId;
import com.hp.util.pkt.Dhcp;
import com.hp.util.pkt.Ethernet;
import com.hp.util.pkt.Packet;
import com.hp.util.pkt.Ip;
import com.hp.util.pkt.IpTosDsfc;

import java.util.Map;
import java.util.Set;
import java.util.HashMap;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.UUID;

import com.hp.api.Id;

import org.apache.felix.scr.annotations.Activate;
import org.apache.felix.scr.annotations.Component;
import org.apache.felix.scr.annotations.Deactivate;
import org.apache.felix.scr.annotations.Reference;
import org.apache.felix.scr.annotations.ReferenceCardinality;
import org.apache.felix.scr.annotations.ReferencePolicy;
import org.apache.felix.scr.annotations.Service;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Sample PathFollower service implementation.
 */
@Component
@Service
public class PathFollowerManager implements PathFollowerService {

	/**
	 * logger for debugging
	 */
	private static final Logger log = LoggerFactory.getLogger(PathFollowerManager.class);
	
	/**
	 * OF constants
	 */
    private static final ProtocolVersion PV = ProtocolVersion.V_1_3;
    private static final TableId TABLE_HARDWARE = TableId.valueOf(100);
    private static final TableId TABLE_SOFTWARE = TableId.valueOf(200);
	private static final int DIRECTOR_ALTITUDE = 100;
    private static final Set<ProtocolId> DIR_INTEREST = EnumSet.of(ProtocolId.IP);
	private static final int PRIORITY_PATH_FOLLOWER = 10;
	
	/**
	 * FlowClass infoOxmBasicFieldTypermation
	 */
	private static final String PASSWD = "password";
	private static final String DEBUG_STEAL_CLASS = "com.uky.pf.debugsteal";
	private static final String DEBUG_STEAL_DESC = "Used to steal debug packets";
	
	private FlowClass debugStealClass;
		
    /**
     * Controller listeners
     */
    private SequencedPacketListener packetListener = new PacketListener();
    
    /**
     * A reference to ControllerService.arg0
     */
    @Reference(name = "ControllerService",
               cardinality = ReferenceCardinality.MANDATORY_UNARY,
               policy = ReferencePolicy.DYNAMIC)
    private ControllerService cs;

    /** Bind hook for the controller service. */
    public void bindControllerService(ControllerService cs) {
        if (null == this.cs) {
        	this.cs = cs;
        	
        	// Register our intent to steal debug packets
        	debugStealClass = new FlowClassRegistrator(DEBUG_STEAL_CLASS, PASSWD, DEBUG_STEAL_DESC)
        				   	  .fields(ETH_TYPE, IP_DSCP)
        				   	  .actions(STEAL)
        				   	  .register(cs);
        	
            cs.addPacketListener(packetListener, PacketListenerRole.DIRECTOR, DIRECTOR_ALTITUDE, DIR_INTEREST);
            
        }
    }

    /** Unbind hook for the controller service. */
    public void unbindControllerService(ControllerService cs) {
        if (this.cs == cs) {
        	cs.unregisterFlowClass(debugStealClass, PASSWD); 
            cs.removePacketListener(packetListener);
            this.cs = null;
        }
    }
    
    @Activate
    public void activate(){
    	/*When the module is activated*/
    	log.info("Debug Module is activated.");
    	if (cs != null) {
    		pushDebugStealRules();
    	}
    }

	@Deactivate
    public void deactivate() {
    	/* When module is deactivated */
    	log.info("Debug Module is deactivated.");
    	if (cs != null) {
    		removeDebugStealRules();
    	}
    }
	
	/**
	 * Pushes steal rule for debug packets to all currently connected switches.
	 */
	private void pushDebugStealRules() {
		for (DataPathInfo dpi : cs.getAllDataPathInfo()) {
			addRule(dpi.dpid(), createDebugSteal(), debugStealClass);
		}
	}
	
	/**
	 * Remove steal rule for debug packets from all currently connected switches.
	 */
	private void removeDebugStealRules() {
		for (DataPathInfo dpi : cs.getAllDataPathInfo()) {
			removeRules(dpi.dpid());
		}
	}
	
	/**
	 * Pushes rule to the specified switch.
	 * @param dpid (datapath id)
	 * @param rule  (rule to be pushed)
	 */
    private void addRule(DataPathId dpid, OfmFlowMod rule, FlowClass purpose) {
		log.debug("Adding rule to switch {}", dpid);
		try {
			cs.sendFlowMod(rule, dpid, purpose);
		} catch (OpenflowException e) {
			log.warn("Unable to add rule", rule, dpid);
		}
		
	}

    /**
     * Removes all rules matching the abase cookie from the given switch.
     * @param dpid
     */
	private void removeRules(DataPathId dpid) {
		// TODO  Figure out this part
		
	}
    
	private OfmFlowMod createDebugSteal() {
		// TODO Come back to this part
		
		Action debugSteal = createAction(PV, ActionType.OUTPUT, Port.CONTROLLER,
							ActOutput.CONTROLLER_NO_BUFFER);
		// TODO: needs to send to the next table
		
		MutableMatch match = createMatch(PV)
							 .addField(createBasicField(PV, ETH_TYPE, EthernetType.IPv4))
							 .addField(createBasicField(PV, IP_DSCP, 4));
		
		OfmMutableFlowMod flow = (OfmMutableFlowMod) 
						MessageFactory.create(PV,MessageType.FLOW_MOD, FlowModCommand.ADD);
		
		flow.bufferId(BufferId.NO_BUFFER)
			.cookie(debugStealClass.baseCookie())
			.priority(debugStealClass.priority())
			.match((Match) (match.toImmutable())).addAction(debugSteal);					 
							
		return (OfmFlowMod) flow.toImmutable();
	}


	/**
	 * Handler for processing packet-in messages for debugging packets
	 */
	private class PacketListener implements SequencedPacketListener {

        @Override
        public void errorEvent(ErrorEvent evt) {
            // This method intentionally empty.
        }

        @Override
        public void event(MessageContext ctx) {
        	if (ctx.isHandled() || ctx.isTestPacket())
        		return;
        	
        	DataPathId temp_dpid = ctx.srcEvent().dpid();    	       	
        	Packet packet = ctx.decodedPacket();
        	
        	if (packet.has(ProtocolId.IP)) {
        		Ip ipPacket = packet.get(ProtocolId.IP);
        		if (ipPacket.tosDsfc().code() == 4) {
        			log.info("event on switch id: {}. packet with TOS field 0x4.", temp_dpid.toString()); 
        			ctx.packetOut().block(); // TODO: change this to an appropriate action later.
        		}	
        	}
        }
	}
}
